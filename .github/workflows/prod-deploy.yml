name: Stage 3 - Deploy to Production (upsert)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read
  id-token: write

env:
  ACR_NAME: ${{ secrets.ACR_NAME }}
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}

  # Prod infra (already created once)
  PROD_RG: ${{ secrets.PROD_RG }}
  PROD_ENV_NAME: ${{ secrets.PROD_ENV_NAME }}

  # App names (override via repo secrets if you use different names in prod)
  CUSTOMER_APP: ${{ secrets.PROD_CUSTOMER_APP || 'customer-service' }}
  PRODUCT_APP:  ${{ secrets.PROD_PRODUCT_APP  || 'product-service'  }}
  ORDER_APP:    ${{ secrets.PROD_ORDER_APP    || 'order-service'    }}
  FRONTEND_APP: ${{ secrets.PROD_FRONTEND_APP || 'frontend'         }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Container Apps extension
        run: az extension add --name containerapp --upgrade -y

      - name: Normalize prod inputs (trim whitespace)
        id: norm
        run: |
          RG_TRIM=$(printf "%s" "$PROD_RG" | tr -d '[:space:]')
          ENV_TRIM=$(printf "%s" "$PROD_ENV_NAME" | tr -d '[:space:]')
          echo "PROD_RG=$RG_TRIM" >> "$GITHUB_ENV"
          echo "PROD_ENV_NAME=$ENV_TRIM" >> "$GITHUB_ENV"
          echo "Using PROD_RG='$RG_TRIM' PROD_ENV_NAME='$ENV_TRIM'"

      - name: Verify Container Apps environment exists
        run: |
          set -e
          az containerapp env list -g "$PROD_RG" -o table || true
          if ! az containerapp env show -g "$PROD_RG" -n "$PROD_ENV_NAME" >/dev/null 2>&1; then
            echo "::error::Container Apps environment '$PROD_ENV_NAME' not found in RG '$PROD_RG'."
            echo "Create it once (Portal/CLI) or fix the secret values."
            exit 1
          fi

      - name: Compute image tag
        id: vars
        run: echo "IMAGE_TAG=${GITHUB_SHA}" >> "$GITHUB_OUTPUT"

      - name: Ensure env can pull from ACR (idempotent)
        run: |
          set -e
          ENV_MI_PRINCIPAL_ID=$(az containerapp env show -g "$PROD_RG" -n "$PROD_ENV_NAME" --query identity.principalId -o tsv || true)
          if [ -n "$ENV_MI_PRINCIPAL_ID" ]; then
            ACR_ID=$(az acr show -n "$ACR_NAME" --query id -o tsv)
            az role assignment create \
              --assignee-object-id "$ENV_MI_PRINCIPAL_ID" \
              --assignee-principal-type ServicePrincipal \
              --role AcrPull \
              --scope "$ACR_ID" >/dev/null 2>&1 || true

            # Newer CLI supports registry on the env; noop if already set
            az containerapp registry set \
              -g "$PROD_RG" \
              --environment "$PROD_ENV_NAME" \
              --server "$ACR_LOGIN_SERVER" \
              --identity system >/dev/null 2>&1 || true
          fi

      - name: Upsert apps in production
        id: upsert
        env:
          IMAGE_TAG: ${{ steps.vars.outputs.IMAGE_TAG }}
        run: |
          set -e
          IMG_CUSTOMER="${ACR_LOGIN_SERVER}/customer-service:${IMAGE_TAG}"
          IMG_PRODUCT="${ACR_LOGIN_SERVER}/product-service:${IMAGE_TAG}"
          IMG_ORDER="${ACR_LOGIN_SERVER}/order-service:${IMAGE_TAG}"
          IMG_FRONTEND="${ACR_LOGIN_SERVER}/frontend:${IMAGE_TAG}"

          upsert () {
            local NAME=$1 PORT=$2 IMAGE=$3 EXTRA_ARGS=${4:-}
            if az containerapp show -g "$PROD_RG" -n "$NAME" >/dev/null 2>&1; then
              az containerapp update -g "$PROD_RG" -n "$NAME" --image "$IMAGE" $EXTRA_ARGS
            else
              az containerapp create -g "$PROD_RG" -n "$NAME" \
                --environment "$PROD_ENV_NAME" \
                --image "$IMAGE" \
                --ingress external --target-port "$PORT" --transport auto \
                $EXTRA_ARGS
            fi
          }

          # 1) customer-service (8002)
          upsert "$CUSTOMER_APP" 8002 "$IMG_CUSTOMER"
          CUSTOMER_FQDN=$(az containerapp show -g "$PROD_RG" -n "$CUSTOMER_APP" --query "properties.configuration.ingress.fqdn" -o tsv)

          # 2) product-service (8003)
          upsert "$PRODUCT_APP" 8003 "$IMG_PRODUCT"

          # 3) order-service (8001) needs CUSTOMER_SERVICE_URL
          upsert "$ORDER_APP" 8001 "$IMG_ORDER" "--env-vars CUSTOMER_SERVICE_URL=http://${CUSTOMER_FQDN}"

          # 4) frontend (80)
          upsert "$FRONTEND_APP" 80 "$IMG_FRONTEND"

          FRONTEND_URL="http://$(az containerapp show -g "$PROD_RG" -n "$FRONTEND_APP" --query "properties.configuration.ingress.fqdn" -o tsv)"
          echo "frontend=${FRONTEND_URL}" >> "$GITHUB_OUTPUT"

      - name: Smoke check
        run: |
          set -e
          sleep 20
          curl -fsS "${{ steps.upsert.outputs.frontend }}" >/dev/null
          echo "Frontend OK at ${{ steps.upsert.outputs.frontend }}"
