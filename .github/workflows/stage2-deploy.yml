name: Stage 2 - Provision Staging & Deploy

on:
  workflow_run:
    workflows: ["CI - Test, Build & Push to ACR (Stage 1)"]  # must exactly match Stage 1 name
    types: [completed]

permissions:
  contents: read
  id-token: write

env:
  LOCATION: australiaeast

  # Use an existing RG if you don't have rights to create new ones.
  # Set RG_NAME to your pre-created group (e.g., sit722-staging-fixed).
  # Leave RG_NAME blank to let the workflow create a temporary RG.
  RG_NAME: sit722-staging-fixed
  RG_PREFIX: sit722-staging

  ACR_NAME: ${{ secrets.ACR_NAME }}
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}

concurrency:
  group: stage2-${{ github.ref }}
  cancel-in-progress: false

jobs:
  deploy-staging:
    # only run if Stage 1 succeeded AND the branch was 'testing'
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'testing' }}
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash

    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure CLI extensions
        run: |
          set -e
          az extension add --name containerapp --upgrade -y
          az extension add --name log-analytics --upgrade -y || true

      - name: Compute variables
        id: vars
        run: |
          set -euo pipefail
          IMAGE_TAG="${{ github.event.workflow_run.head_sha }}"

          # If RG_NAME is provided, use it; else synthesize a temp RG name.
          if [[ -n "${RG_NAME:-}" ]]; then
            RG="$RG_NAME"
          else
            RG="${RG_PREFIX}-${GITHUB_RUN_ID}"
          fi

          ENV_NAME="aca-${GITHUB_RUN_ID}"

          echo "IMAGE_TAG=$IMAGE_TAG" >> "$GITHUB_OUTPUT"
          echo "RG=$RG"               >> "$GITHUB_OUTPUT"
          echo "ENV_NAME=$ENV_NAME"   >> "$GITHUB_OUTPUT"

      - name: Ensure resource group exists (no-op if pre-created)
        run: |
          set -e
          if az group show -n "${{ steps.vars.outputs.RG }}" >/dev/null 2>&1; then
            echo "RG exists: ${{ steps.vars.outputs.RG }}"
          else
            echo "Creating RG: ${{ steps.vars.outputs.RG }}"
            az group create -n "${{ steps.vars.outputs.RG }}" -l "${{ env.LOCATION }}"
          fi

      - name: Ensure providers registered
        run: |
          az provider register --namespace Microsoft.App --wait
          az provider register --namespace Microsoft.OperationalInsights --wait

      # ---------- LOG ANALYTICS (sanitize GUID) ----------
      - name: Create/resolve Log Analytics workspace
        id: la
        run: |
          set -euo pipefail
          LA_NAME="la-${GITHUB_RUN_ID}"

          if ! az monitor log-analytics workspace show -g "${{ steps.vars.outputs.RG }}" -n "$LA_NAME" >/dev/null 2>&1; then
            az monitor log-analytics workspace create \
              -g "${{ steps.vars.outputs.RG }}" \
              -n "$LA_NAME" \
              -l "${{ env.LOCATION }}" >/dev/null
          fi

          LA_CUSTOMER_ID=$(az monitor log-analytics workspace show \
            -g "${{ steps.vars.outputs.RG }}" -n "$LA_NAME" --query customerId -o tsv | tr -d '[:space:]')
          LA_KEY=$(az monitor log-analytics workspace get-shared-keys \
            -g "${{ steps.vars.outputs.RG }}" -n "$LA_NAME" --query primarySharedKey -o tsv | tr -d '[:space:]')

          # Validate: must look like a 36-char GUID
          if ! [[ "$LA_CUSTOMER_ID" =~ ^[0-9a-fA-F-]{36}$ ]]; then
            echo "Bad Log Analytics customerId: '$LA_CUSTOMER_ID'" >&2
            exit 1
          fi

          echo "customerId=$LA_CUSTOMER_ID" >> "$GITHUB_OUTPUT"
          echo "key=$LA_KEY"               >> "$GITHUB_OUTPUT"

      # ---------- CONTAINER APPS ENV ----------
      - name: Create Container Apps environment
        run: |
          set -e
          az containerapp env create \
            -g "${{ steps.vars.outputs.RG }}" \
            -n "${{ steps.vars.outputs.ENV_NAME }}" \
            -l "${{ env.LOCATION }}" \
            --logs-workspace-id  "${{ steps.la.outputs.customerId }}" \
            --logs-workspace-key "${{ steps.la.outputs.key }}"

      # Assign a system-assigned identity to the env (separate command)
      - name: Assign system identity to env
        run: |
          set -e
          az containerapp env identity assign \
            -g "${{ steps.vars.outputs.RG }}" \
            -n "${{ steps.vars.outputs.ENV_NAME }}" \
            --system-assigned

      # ---------- REGISTRY PULL (ACR) ----------
      - name: Grant env identity ACR Pull & set registry
        run: |
          set -euo pipefail
          ACR_ID=$(az acr show -n "${{ env.ACR_NAME }}" --query id -o tsv)
          ENV_MI_PRINCIPAL_ID=$(az containerapp env show \
            -g "${{ steps.vars.outputs.RG }}" \
            -n "${{ steps.vars.outputs.ENV_NAME }}" \
            --query identity.principalId -o tsv)

          # Allow the env identity to pull from your ACR
          az role assignment create \
            --assignee-object-id "$ENV_MI_PRINCIPAL_ID" \
            --assignee-principal-type ServicePrincipal \
            --role AcrPull \
            --scope "$ACR_ID"

          # Configure the env to use your ACR via its system identity
          az containerapp registry set \
            -g "${{ steps.vars.outputs.RG }}" \
            --environment "${{ steps.vars.outputs.ENV_NAME }}" \
            --server "${{ env.ACR_LOGIN_SERVER }}" \
            --identity system

      # ---------- APPS DEPLOY ----------
      - name: Deploy/Update services (Container Apps)
        id: deploy
        run: |
          set -euo pipefail
          IMAGE_TAG="${{ steps.vars.outputs.IMAGE_TAG }}"
          RG="${{ steps.vars.outputs.RG }}"
          ENV_NAME="${{ steps.vars.outputs.ENV_NAME }}"

          upsert_app () {
            local NAME=$1
            local PORT=$2
            local IMAGE=$3
            local EXTRA_ARGS=${4:-}
            if az containerapp show -g "$RG" -n "$NAME" >/dev/null 2>&1; then
              az containerapp update -g "$RG" -n "$NAME" --image "$IMAGE" $EXTRA_ARGS
            else
              az containerapp create -g "$RG" -n "$NAME" \
                --environment "$ENV_NAME" \
                --image "$IMAGE" \
                --ingress external --target-port "$PORT" --transport auto \
                $EXTRA_ARGS
            fi
          }

          # customer-service (8002)
          upsert_app "customer-service" 8002 "${{ env.ACR_LOGIN_SERVER }}/customer-service:${IMAGE_TAG}"
          CUSTOMER_FQDN=$(az containerapp show -g "$RG" -n customer-service --query "properties.configuration.ingress.fqdn" -o tsv)

          # product-service (8003)
          upsert_app "product-service"  8003 "${{ env.ACR_LOGIN_SERVER }}/product-service:${IMAGE_TAG}"
          PRODUCT_FQDN=$(az containerapp show -g "$RG" -n product-service --query "properties.configuration.ingress.fqdn" -o tsv)

          # order-service (8001) depends on customer URL
          upsert_app "order-service"    8001 "${{ env.ACR_LOGIN_SERVER }}/order-service:${IMAGE_TAG}" "--env-vars CUSTOMER_SERVICE_URL=http://${CUSTOMER_FQDN}"
          ORDER_FQDN=$(az containerapp show -g "$RG" -n order-service --query "properties.configuration.ingress.fqdn" -o tsv)

          # frontend (80)
          upsert_app "frontend"           80 "${{ env.ACR_LOGIN_SERVER }}/frontend:${IMAGE_TAG}"
          FRONTEND_FQDN=$(az containerapp show -g "$RG" -n frontend --query "properties.configuration.ingress.fqdn" -o tsv)

          echo "CUSTOMER_URL=http://${CUSTOMER_FQDN}"  >> "$GITHUB_OUTPUT"
          echo "PRODUCT_URL=http://${PRODUCT_FQDN}"    >> "$GITHUB_OUTPUT"
          echo "ORDER_URL=http://${ORDER_FQDN}"        >> "$GITHUB_OUTPUT"
          echo "FRONTEND_URL=http://${FRONTEND_FQDN}"  >> "$GITHUB_OUTPUT"

      - name: Smoke test (light)
        run: |
          set -e
          echo "Waiting for apps to warm up..."
          sleep 30
          curl -fsS "${{ steps.deploy.outputs.FRONTEND_URL }}" >/dev/null
          curl -fsS "${{ steps.deploy.outputs.CUSTOMER_URL }}/health" || true
          curl -fsS "${{ steps.deploy.outputs.PRODUCT_URL }}/health"  || true
          curl -fsS "${{ steps.deploy.outputs.ORDER_URL }}/health"    || true

      - name: Save RG/env for teardown
        run: |
          echo "${{ steps.vars.outputs.RG }}"       > staging-rg.txt
          echo "${{ steps.vars.outputs.ENV_NAME }}" > staging-env.txt

      - uses: actions/upload-artifact@v4
        with:
          name: staging-info
          path: |
            staging-rg.txt
            staging-env.txt

      - name: Print URLs
        run: |
          echo "FRONTEND: ${{ steps.deploy.outputs.FRONTEND_URL }}"
          echo "CUSTOMER: ${{ steps.deploy.outputs.CUSTOMER_URL }}"
          echo "PRODUCT : ${{ steps.deploy.outputs.PRODUCT_URL }}"
          echo "ORDER   : ${{ steps.deploy.outputs.ORDER_URL }}"
