name: Stage 2 - Provision Staging & Deploy (Minimal, Works)

on:
  workflow_run:
    workflows: ["CI - Test, Build & Push to ACR (Stage 1)"]   # must match Stage 1 name exactly
    types: [completed]

permissions:
  contents: read
  id-token: write

env:
  # Use the fixed RG you granted Contributor to:
  STAGING_RG: sit722-staging-fixed
  LOCATION: australiaeast
  ACR_NAME: ${{ secrets.ACR_NAME }}
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}

concurrency:
  group: stage2-${{ github.ref }}
  cancel-in-progress: false

jobs:
  deploy-staging:
    # run only if Stage 1 succeeded and was for 'testing' branch
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'testing' }}
    runs-on: ubuntu-latest

    steps:
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install Azure CLI extensions
        run: |
          set -e
          az extension add --name containerapp --upgrade -y

      - name: Compute variables
        id: vars
        shell: bash
        run: |
          echo "IMAGE_TAG=${{ github.event.workflow_run.head_sha }}" >> "$GITHUB_OUTPUT"
          echo "ENV_NAME=aca-${{ github.run_id }}"                   >> "$GITHUB_OUTPUT"

      # OPTIONAL: ensure the target RG exists (will succeed if it already exists)
      - name: Ensure resource group exists
        run: |
          az group create -n "${{ env.STAGING_RG }}" -l "${{ env.LOCATION }}"

      # Create Container Apps environment (NO Log Analytics, NO identity)
      - name: Create Container Apps environment
        run: |
          if ! az containerapp env show -g "${{ env.STAGING_RG }}" -n "${{ steps.vars.outputs.ENV_NAME }}" >/dev/null 2>&1; then
            az containerapp env create \
              -g "${{ env.STAGING_RG }}" \
              -n "${{ steps.vars.outputs.ENV_NAME }}" \
              -l "${{ env.LOCATION }}"
          else
            echo "Env exists: ${{ steps.vars.outputs.ENV_NAME }}"
          fi

      # Get ACR credentials (preferred) OR use secrets fallback
      - name: Resolve ACR credentials
        id: acr
        shell: bash
        run: |
          set -e
          USERNAME=""
          PASSWORD=""

          if az acr show -n "${{ env.ACR_NAME }}" >/dev/null 2>&1; then
            USERNAME=$(az acr credential show -n "${{ env.ACR_NAME }}" --query "username" -o tsv)
            PASSWORD=$(az acr credential show -n "${{ env.ACR_NAME }}" --query "passwords[0].value" -o tsv)
          fi

          # Fallback to repo secrets if credential show is blocked by RBAC
          if [ -z "$USERNAME" ] || [ -z "$PASSWORD" ]; then
            USERNAME="${{ secrets.ACR_USERNAME }}"
            PASSWORD="${{ secrets.ACR_PASSWORD }}"
          fi

          if [ -z "$USERNAME" ] || [ -z "$PASSWORD" ]; then
            echo "ACR credentials not available. Provide ACR_USERNAME/ACR_PASSWORD repo secrets or grant 'AcrPull' and 'AcrPush' to this principal."
            exit 1
          fi

          echo "username=$USERNAME" >> "$GITHUB_OUTPUT"
          echo "password=$PASSWORD" >> "$GITHUB_OUTPUT"

      # Deploy / Update apps (use registry creds directly)
      - name: Deploy/Update services (Container Apps)
        id: deploy
        shell: bash
        run: |
          set -e
          RG="${{ env.STAGING_RG }}"
          ENV_NAME="${{ steps.vars.outputs.ENV_NAME }}"
          IMAGE_TAG="${{ steps.vars.outputs.IMAGE_TAG }}"
          REG_SERVER="${{ env.ACR_LOGIN_SERVER }}"
          REG_USER="${{ steps.acr.outputs.username }}"
          REG_PASS="${{ steps.acr.outputs.password }}"

          upsert_app () {
            local NAME=$1
            local PORT=$2
            local IMAGE=$3
            local EXTRA_ARGS=${4:-}
            if az containerapp show -g "$RG" -n "$NAME" >/dev/null 2>&1; then
              az containerapp update -g "$RG" -n "$NAME" \
                --image "$IMAGE" \
                --registry-server "$REG_SERVER" \
                --registry-username "$REG_USER" \
                --registry-password "$REG_PASS" \
                $EXTRA_ARGS
            else
              az containerapp create -g "$RG" -n "$NAME" \
                --environment "$ENV_NAME" \
                --image "$IMAGE" \
                --ingress external --target-port "$PORT" --transport auto \
                --registry-server "$REG_SERVER" \
                --registry-username "$REG_USER" \
                --registry-password "$REG_PASS" \
                $EXTRA_ARGS
            fi
          }

          # customer-service (8002)
          upsert_app "customer-service" 8002 "${REG_SERVER}/customer-service:${IMAGE_TAG}"
          CUSTOMER_FQDN=$(az containerapp show -g "$RG" -n customer-service --query "properties.configuration.ingress.fqdn" -o tsv)

          # product-service (8003)
          upsert_app "product-service"  8003 "${REG_SERVER}/product-service:${IMAGE_TAG}"
          PRODUCT_FQDN=$(az containerapp show -g "$RG" -n product-service --query "properties.configuration.ingress.fqdn" -o tsv)

          # order-service (8001) depends on customer URL
          upsert_app "order-service" 8001 "${REG_SERVER}/order-service:${IMAGE_TAG}" "--env-vars CUSTOMER_SERVICE_URL=http://${CUSTOMER_FQDN}"
          ORDER_FQDN=$(az containerapp show -g "$RG" -n order-service --query "properties.configuration.ingress.fqdn" -o tsv)

          # frontend (80)
          upsert_app "frontend" 80 "${REG_SERVER}/frontend:${IMAGE_TAG}"
          FRONTEND_FQDN=$(az containerapp show -g "$RG" -n frontend --query "properties.configuration.ingress.fqdn" -o tsv)

          echo "CUSTOMER_URL=http://${CUSTOMER_FQDN}"  >> "$GITHUB_OUTPUT"
          echo "PRODUCT_URL=http://${PRODUCT_FQDN}"    >> "$GITHUB_OUTPUT"
          echo "ORDER_URL=http://${ORDER_FQDN}"        >> "$GITHUB_OUTPUT"
          echo "FRONTEND_URL=http://${FRONTEND_FQDN}"  >> "$GITHUB_OUTPUT"

      - name: Smoke test (light)
        shell: bash
        run: |
          set -e
          echo "Waiting for apps to warm up..."
          sleep 30
          curl -fsS "${{ steps.deploy.outputs.FRONTEND_URL }}" >/dev/null
          curl -fsS "${{ steps.deploy.outputs.CUSTOMER_URL }}/health" || true
          curl -fsS "${{ steps.deploy.outputs.PRODUCT_URL }}/health"  || true
          curl -fsS "${{ steps.deploy.outputs.ORDER_URL }}/health"    || true

      - name: Print URLs
        run: |
          echo "FRONTEND: ${{ steps.deploy.outputs.FRONTEND_URL }}"
          echo "CUSTOMER: ${{ steps.deploy.outputs.CUSTOMER_URL }}"
          echo "PRODUCT : ${{ steps.deploy.outputs.PRODUCT_URL }}"
          echo "ORDER   : ${{ steps.deploy.outputs.ORDER_URL }}"
